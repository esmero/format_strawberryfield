<?php

namespace Drupal\format_strawberryfield_views\Plugin\views\style;

use Drupal\Component\Utility\NestedArray;
use Drupal\Component\Utility\UrlHelper;
use Drupal\Component\Utility\Xss;
use Drupal\Core\Field\FieldItemInterface;
use Drupal\views\Plugin\views\style\StylePluginBase;
use Drupal\Core\Form\FormStateInterface;
use Drupal\views\ResultRow;

/**
 * Style plugin to render a LeafletMap from a SBF.
 *
 * @ingroup views_style_plugins
 *
 * @ViewsStyle(
 *   id = "format_strawberryfield_views_leaflet",
 *   title = @Translation("Leaftlet Map from a Strawberryfield cast into GeoJSON"),
 *   help = @Translation("Displays a Leaflet map using GeoJSON features produced by Strawberryfields JSON cast via a Metatdata Display."),
 *   theme = "format_strawberryfield_views_leaflet",
 *   display_types = {"normal"}
 * )
 */
class LeaftletGeoJSON extends StylePluginBase {

  /**
   * {@inheritdoc}
   */
  protected $usesRowPlugin = TRUE;

  /**
   * {@inheritdoc}
   */
  protected $usesFields = TRUE;

  /**
   * {@inheritdoc}
   */
  protected function defineOptions() {
    $options = parent::defineOptions();
    $options['metadataexposeentity_source'] = ['default' => NULL];
    $options['mediasource'] = ['default' => ''];
    $options['main_mediasource'] = ['default' => ''];
    $options['tilemap_url'] = ['default' => 'https://a.tile.openstreetmap.org/{z}/{x}/{y}.png'];
    $options['max_width'] = ['default' => 0];
    $options['max_height'] = ['default' => '700'];
    $options['initial_zoom'] = ['default' => '10'];
    $options['max_zoom'] = ['default' => '22'];
    $options['min_zoom'] = ['default' => '1'];

    return $options;
  }

  /**
   * {@inheritdoc}
   */
  public function buildOptionsForm(&$form, FormStateInterface $form_state) {
    parent::buildOptionsForm($form, $form_state);

    /* setup */
    $exposed_metadata_display_entity = NULL;
    $metadata_display_entity = NULL;

    if ($this->options['metadataexposeentity_source']) {
      $exposed_metadata_display_entity = \Drupal::service('entity_type.manager')->getStorage(
        'metadataexpose_entity'
      )->load($this->options['metadataexposeentity_source']);
    }

    if ($this->options['metadatadisplayentity_uuid']) {
      $metadata_display_entity = \Drupal::service('entity_type.manager')->getStorage('metadatadisplay_entity')->loadByProperties(['uuid' => $this->options['metadatadisplayentity_uuid']]);
      $metadata_display_entity = reset($metadata_display_entity);
    }

    $options_for_mainsource = is_array(
      $this->options['mediasource']
    )
    && !empty($this->options['mediasource']) ? $this->options['mediasource']
      : $this->defineOptions()['mediasource'];
    if (($triggering_element = $form_state->getTriggeringElement())
      && isset($triggering_element['#ajax']['callback'])
    ) {
      // We are getting the actual checkbox value pressed in the parents array.
      // so we need to slice by 1 at the end.
      // if Ajax class of the triggering element is this class then process
      if ($triggering_element['#ajax']['callback'][0] == get_class($this)) {
        $parents = array_slice($triggering_element['#parents'], 0, -1);
        $options_for_mainsource = $form_state->getValue($parents);
      }
    }
    $all_options_form_source = [
      'metadataexposeentity' => $this->t(
        'GeoJSON generated by an Exposed Metadata Display Entity'
      )
    ];
    $options_for_mainsource = array_filter($options_for_mainsource);
    $options_for_mainsource = array_intersect_key(
      $options_for_mainsource,
      $all_options_form_source
    );

    // Define #ajax callback.
    $ajax = [
      'callback' => __CLASS__ . '::ajaxCallbackMainSource',
      'wrapper'  => 'main-mediasource-ajax-container',
    ];
    // Because main media source needs to update its choices based on
    // Media Source checked options, we need to recalculate its default
    // Value also.
    $default_value_main_mediasoruce = ($this->options['main_mediasource']
      && array_key_exists(
        $this->options['main_mediasource'],
        $options_for_mainsource
      ))
      ? $this->options['main_mediasource']
      : reset(
        $options_for_mainsource
      );

    $form['tilemap_url'] = [
      '#type'          => 'textfield',
      '#title'         => t('Base Map (Tiles) URL to use on this Map'),
      '#description'   => t(
        'E.g https://a.tile.openstreetmap.org/{z}/{x}/{y}.png'
      ),
      '#default_value' => trim($this->options['tilemap_url']),
      '#required'      => TRUE,
    ];
    $form['tilemap_attribution'] = [
      '#type'          => 'textfield',
      '#title'         => t('Attribution HTML string for the Base Map.'),
      '#description'   => t(
        'E.g &amp;copy; &lt;a href=&quot;https://openstreetmap.org/copyright&quot;&gt;OpenStreetMap contributors&lt;/a&gt;'
      ),
      '#default_value' => trim($this->options['tilemap_attribution']),
      '#required'      => TRUE,
    ];

    $form['metadataexposeentity_source'] = [
      '#type'               => 'entity_autocomplete',
      '#target_type'        => 'metadataexpose_entity',
      '#title'              => $this->t(
        'Select which Exposed Metadata Endpoint will generate the GeoJSON'
      ),
      '#description'        => $this->t(
        'This value is used for Metadata Exposed Entities and also for Node Lists as Processing source for GeoJSON'
      ),
      '#selection_handler'  => 'default',
      '#validate_reference' => TRUE,
      '#default_value'      => $exposed_metadata_display_entity,
      '#states'             => [
        [
          'visible' => [
            ':input[data-formatter-selector="mediasource"][value="metadataexposeentity"]' => ['checked' => TRUE],
          ],
        ],
        [
          'visible' => [
            ':input[data-formatter-selector="mediasource"][value="geojsonnodelist"]' => ['checked' => TRUE],
          ],
        ],
      ],
    ];

    $form['max_width'] = [
      '#type'          => 'number',
      '#title'         => $this->t('Maximum width'),
      '#description'   => $this->t('Use 0 to force 100% width'),
      '#default_value' => $this->options['max_width'],
      '#size'          => 5,
      '#maxlength'     => 5,
      '#field_suffix'  => $this->t('pixels'),
      '#min'           => 0,
      '#required'      => TRUE,
    ];
    $form['max_height'] = [
      '#type'          => 'number',
      '#title'         => $this->t('Maximum height'),
      '#default_value' => $this->options['max_height'],
      '#size'          => 5,
      '#maxlength'     => 5,
      '#field_suffix'  => $this->t('pixels'),
      '#min'           => 0,
      '#required'      => TRUE,
    ];
    $form['initial_zoom'] = [
      '#type'          => 'number',
      '#title'         => $this->t('Initial Zoom'),
      '#description'   => $this->t(
        'Only applies when a single Point is in the map. When more fit to bounds apply.'
      ),
      '#default_value' => $this->options['initial_zoom'],
      '#size'          => 2,
      '#maxlength'     => 2,
      '#min'           => 1,
      '#max'           => 22,
    ];
    $form['min_zoom'] = [
      '#type'          => 'number',
      '#title'         => $this->t('Minimum possible Zoom'),
      '#default_value' => $this->options['min_zoom'],
      '#size'          => 2,
      '#maxlength'     => 2,
      '#min'           => 0,
      '#max'           => 22,
    ];
    $form['max_zoom'] = [
      '#type'          => 'number',
      '#title'         => $this->t('Maximum possible Zoom'),
      '#default_value' => $this->options['max_zoom'],
      '#size'          => 2,
      '#maxlength'     => 2,
      '#min'           => 0,
      '#max'           => 22,
    ];
  }
  /**
   * Ajax callback.
   *
   * @param array $form
   *   An associative array containing the structure of the form.
   * @param \Drupal\Core\Form\FormStateInterface $form_state
   *   The current state of the form.
   *
   * @return array
   *   An associative array containing entity reference details element.
   */
  public function ajaxCallbackMainSource(
    array $form,
    FormStateInterface $form_state
  ) {
    $form_parents = $form_state->getTriggeringElement()['#array_parents'];
    $form_parents = array_slice($form_parents, 0, -2);
    $form_parents[] = 'main_mediasource';
    return NestedArray::getValue($form, $form_parents);
  }


  /**
   * {@inheritdoc}
   */
  public function render() {

    // Render the fields.  If it isn't done now then the row_index will be unset
    // the first time that getField() is called, resulting in an undefined
    // property exception.
    // Group the rows according to the grouping field, if specified.
    // Setting FALSE here
    $sets = $this->renderGrouping($this->view->result, $this->options['grouping'], TRUE);

    // Grab the alias of the 'id' field added by
    // entity_reference_plugin_display.
    //$id_field_alias = $this->view->storage->get('base_field');

    //$this->renderFields($this->view->result);
    $source_entity_grouped_uuids = [];
    $source_entity_uuids = [];
    foreach ($sets as $group => $records) {
      foreach ($records['rows'] ?? [] as $row) {
        $node = NULL;
        if ($row instanceof \Drupal\search_api\Plugin\views\ResultRow) {
          if ($row->search_api_datasource == 'entity:node') {
            $node = $this->getEntity($row);
            if ($node) {
              if (empty($group)) {
                $source_entity_uuids[] = $node->uuid();
              }
              else {
                $source_entity_grouped_uuids[$group][] =  $node->uuid();
              }
            }
          }
        }
        else {
          $node = $this->getEntity($row);
          // SQL queries will only work for Nodes, so we are well here?
          if ($node) {
            if (empty($group)) {
              $source_entity_uuids[] = $node->uuid();
            }
            else {
              $source_entity_grouped_uuids[$group][] =  $node->uuid();
            }
          }
        }
      }
    }
    // Render slide arrays from the views data.
    foreach ($this->view->result as $row_index => $row) {
      //@TODO we can reuse the Lazy load idea here since we really only
      // need the Entities ID or UUID when the time comes to fetch
      // The GeoJSON from the remote URI. This can be an Option
      // if $row->_item strawberryfield_flavor_datasource
      $node = NULL;
      if ($row instanceof \Drupal\search_api\Plugin\views\ResultRow) {
        if ($row->search_api_datasource == 'entity:node') {
          $node = $this->getEntity($row);
          if ($node) {
            $source_entity_uuids[] = $node->uuid();
          }
        }
      }
      else {
        $node = $this->getEntity($row);
        // SQL queries will only work for Nodes, so we are well here?
        if ($node) {
          $source_entity_uuids[] = $node->uuid();
        }
      }
    }
    unset($node);
    unset($this->view->row_index);

    // Skip theming if the view is being edited or previewed.
    if ($this->view->live_preview ?? FALSE) {
      return $this->t('<h2>List of Node UUIDs that for which GeoJSONs will be fetched</h2>'). '<pre>' . print_r($source_entity_uuids + $source_entity_grouped_uuids, true) . '</pre>';
    }

    return [
      '#theme' => $this->themeFunctions(),
      '#view' => $this->view,
      '#options' => [
        'leaflet_options' => $this->options,
      ],
      '#rows' => ['ungrouped' => $source_entity_uuids, 'grouped' => $source_entity_grouped_uuids],
    ];
  }
  public function renderGrouping($records, $groupings = [], $group_rendered = TRUE) {

    if (is_string($groupings)) {
      $rendered = $group_rendered === NULL ? TRUE : $group_rendered;
      $groupings = [['field' => $groupings, 'rendered' => $rendered]];
    }

    // Make sure fields are rendered
    $this->renderFields($this->view->result);
    $sets = [];
    if ($groupings) {
      foreach ($records as $index => $row) {
        // Iterate through configured grouping fields to determine the
        // hierarchically positioned set where the current row belongs to.
        // While iterating, parent groups, that do not exist yet, are added.
        $set = &$sets;
        foreach ($groupings as $level => $info) {
          $field = $info['field'];
          $rendered = $info['rendered'] ?? $group_rendered;
          $rendered_strip = $info['rendered_strip'] ?? FALSE;
          $grouping = '';
          $group_content = '';
          // Group on the rendered version of the field, not the raw.  That way,
          // we can control any special formatting of the grouping field through
          // the admin or theme layer or anywhere else we'd like.
          if (isset($this->view->field[$field])) {
            $group_content = $this->getField($index, $field);
            if ($this->view->field[$field]->options['label']) {
              $delimiter = $this->view->field[$field]->options['element_label_colon'] ? ': ' : ' ';
              $group_content = $this->view->field[$field]->options['label'] . $delimiter . $group_content;
            }
            if ($rendered) {
              $grouping = (string) $group_content;
              if ($rendered_strip) {
                $group_content = $grouping = strip_tags(htmlspecialchars_decode($group_content));
              }
            }
            else {
              $grouping = $this->getFieldValue($index, $field);
              // Not all field handlers return a scalar value,
              // e.g. views_handler_field_field.
              if (!is_scalar($grouping)) {
                $grouping = hash('sha256', serialize($grouping));
              }
            }
          }

          // Create the group if it does not exist yet.
          if (!isset($set[$grouping])) {
            $set[$grouping]['group'] = $group_content;
            $set[$grouping]['level'] = $level;
            $set[$grouping]['rows'] = [];
          }

          // Move the set reference into the row set of the group we just determined.
          $set = &$set[$grouping]['rows'];
        }
        // Add the row to the hierarchically positioned row set we just determined.
        $set[$index] = $row;
      }
    }
    else {
      // Create a single group with an empty grouping field.
      $sets[''] = [
        'group' => '',
        'rows' => $records,
      ];
    }
    return $sets;
  }

  /**
   * {@inheritdoc}
   */
  public function getEntity(ResultRow $values) {
    $relationship_id = $this->options['relationship'] ?? NULL;
    if ($relationship_id == 'none' || empty($relationship_id)) {
      // Search API Rows and _object instead of _entity
      if (!empty($values->_entity)) {
        return $values->_entity;
      }
      elseif (!empty($values->_object)) {
        return $values->_object->getValue();
      }
      else {
        return NULL;
      }
    }
    elseif (isset($values->_relationship_entities[$relationship_id]) && !empty($values->_relationship_objects[$relationship_id][0])) {
      return $values->_relationship_entities[$relationship_id];
    }
    elseif (isset($values->_relationship_objects[$relationship_id][0]) && !empty($values->_relationship_objects[$relationship_id][0])) {
      return $values->_relationship_objects[$relationship_id][0]->getValue();
    }
  }
}
